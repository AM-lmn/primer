---
title: "Prediction Game"
author: "David Kane"
date: "12/23/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(primer.data)
```


### Prediction Game

Let's play a prediction game. Consider the `kenya` tibble from **primer.datta**.

```{r}
kenya
```

The game is that we will pick a random value of `rv13`, which is the number of people who live in the vicinity of a polling station. You guess a number. I guess a number. The winner of the Prediction Game is the person whose guess is closest to the random value selected. Example:

```{r}
your_guess <- 500
my_guess <- 600

sampled_value <- kenya %>% 
  sample_n(1) %>% 
  select(rv13) %>% 
  as_vector()

your_error <- abs(your_guess - sampled_value)
my_error <- abs(my_guess - sampled_value)

if(your_error < my_error) cat("You win!")
if(your_error > my_error) cat("I win!")
```


Run this code in your R Console to try it out. It works! It is also sloppy and disorganized. But the first step in writting good code is to write bad code.

We don't want to play the Prediction Game just once. We want to do it thousands of times. Copy/pasting this code a thousand times would be stupid. Instead, we need a function. Just place the working code within a function definition, and Voila!

```{r}
prediction_game <- function(){
your_guess <- 500
my_guess <- 600

sampled_value <- kenya %>% 
  sample_n(1) %>% 
  select(rv13) %>% 
  as_vector()

your_error <- abs(your_guess - sampled_value)
my_error <- abs(my_guess - sampled_value)

if(your_error < my_error) cat("You win!")
if(your_error > my_error) cat("I win!")
}
```

Other than the function definition itself, there are no changes. Yet, by creating a function, we can now easily run this multiple times.

```{r}
for(i in 1:10){
  prediction_game()
}
```


<!-- DK: Insert a detailed discussion about how we take this garbage and turn it into something much cleaner, pulling out the various lessons we want to teach readers. Final version, after several versions, each one a bit better, should look something like: -->


```{r}
prediction_game <- function(guess_1, guess_2){

  stopifnot(is.numeric(guess_1))
  stopifnot(is.numeric(guess_2))

  
sampled_value <- kenya %>% 
  sample_n(1) %>% 
  select(rv13) %>% 
  as_vector()

your_error <- abs(your_guess - sampled_value)
my_error <- abs(my_guess - sampled_value)

if(your_error < my_error){ 
  return(paste("Guess", guess_1, "wins!"))
}
if(your_error > my_error){ 
  return(paste("Guess", guess_2, "wins!"))
}
if(your_error == my_error){ 
  return("A tie!")
}

}
```

Calling this function is easy. Having it `return()` a result is much more robust that `cat`ing something to the screen.

```{r}
map_chr(1:10, ~ prediction_game(500, 600))
```

In general, we will want to store the results in a tibble, which makes later analysis and plotting easier.

```{r}
tibble(ID = 1:10) %>% 
  mutate(result = map_chr(ID, ~ prediction_game(500, 600)))
```

Who wins the game the most if we play 1,000 times?

```{r}
tibble(ID = 1:1000) %>% 
  mutate(result = map_chr(ID, ~ prediction_game(500, 600))) %>% 
  ggplot(aes(result)) +
    geom_bar()
```

It is hardly surprising that 500 wins more often than 600 since the mean of `rv13` is `r mean(kenya$rv13)`. The mean seems like a pretty good guess. But it is not the best guess.

```{r}
tibble(ID = 1:1000) %>% 
  mutate(result = map_chr(ID, ~ prediction_game(442, 539))) %>% 
  ggplot(aes(result)) +
    geom_bar()
```

The mean is not a bad prediction. But the best prediction is (surprisingly?) the median, which is `r median(kenya$rv13)`.

