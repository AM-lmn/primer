---
title: "Prediction Game"
author: "David Kane"
date: "12/23/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(primer.data)
```


### Prediction Game

Let's play a prediction game. Consider the `kenya` tibble from **primer.datta**.

```{r}
kenya
```

The game is that we will pick a random value of `rv13`, which is the number of people who live in the vicinity of a polling station. You guess a number. I guess a number. The winner of the Prediction Game is the person whose guess is closest to the random value selected. Example:

```{r}
your_guess <- 500
my_guess <- 600

sampled_value <- kenya %>% 
  sample_n(1) %>% 
  select(rv13) %>% 
  as_vector()

your_error <- abs(your_guess - sampled_value)
my_error <- abs(my_guess - sampled_value)

if(your_error < my_error) cat("You win!")
if(your_error > my_error) cat("I win!")
```


Run this code in your R Console to try it out. It works! It is also sloppy and disorganized. But the first step in writting good code is to write bad code.

We don't want to play the Prediction Game just once. We want to do it thousands of times. Copy/pasting this code a thousand times would be stupid. Instead, we need a function. Just place the working code within a function definition, and Voila!

```{r}
prediction_game <- function(){
your_guess <- 500
my_guess <- 600

sampled_value <- kenya %>% 
  sample_n(1) %>% 
  select(rv13) %>% 
  as_vector()

your_error <- abs(your_guess - sampled_value)
my_error <- abs(my_guess - sampled_value)

if(your_error < my_error) cat("You win!")
if(your_error > my_error) cat("I win!")
}
```

Other than the function definition itself, there are no changes. Yet, by creating a function, we can now easily run this multiple times.

```{r}
for(i in 1:10){
  prediction_game()
}
```


<!-- DK: Insert a detailed discussion about how we take this garbage and turn it into something much cleaner, pulling out the various lessons we want to teach readers. Final version, after several versions, each one a bit better, should look something like: -->


```{r}
prediction_game <- function(guess_1, guess_2){

  stopifnot(is.numeric(guess_1))
  stopifnot(is.numeric(guess_2))

  
sampled_value <- kenya %>% 
  sample_n(1) %>% 
  select(rv13) %>% 
  as_vector()

your_error <- abs(your_guess - sampled_value)
my_error <- abs(my_guess - sampled_value)

if(your_error < my_error){ 
  return(paste("Guess", guess_1, "wins!"))
}
if(your_error > my_error){ 
  return(paste("Guess", guess_2, "wins!"))
}
if(your_error == my_error){ 
  return("A tie!")
}

}
```

Calling this function is easy. Having it `return()` a result is much more robust that `cat`ing something to the screen.

```{r}
map_chr(1:10, ~ prediction_game(500, 600))
```

In general, we will want to store the results in a tibble, which makes later analysis and plotting easier.

```{r}
tibble(ID = 1:10) %>% 
  mutate(result = map_chr(ID, ~ prediction_game(500, 600)))
```

Who wins the game the most if we play 1,000 times?

```{r}
tibble(ID = 1:1000) %>% 
  mutate(result = map_chr(ID, ~ prediction_game(500, 600))) %>% 
  ggplot(aes(result)) +
    geom_bar()
```

It is hardly surprising that 500 wins more often than 600 since the mean of `rv13` is `r mean(kenya$rv13)`. The mean seems like a pretty good guess. But it is not the best guess.

```{r}
tibble(ID = 1:1000) %>% 
  mutate(result = map_chr(ID, ~ prediction_game(442, 539))) %>% 
  ggplot(aes(result)) +
    geom_bar()
```

The mean is not a bad prediction. But the best prediction is (surprisingly?) the median, which is `r median(kenya$rv13)`.

#### Playing within a tibble

In other cases, it is more convenient to play portions of the Prediction Game within a tibble. Imagine that we are trying to guess the biggest value out of 10 random samples. We can do this by having a helper function which returns that vector and then, within a tibble, determining who has won.

```{r}
grab_a_sample <- function(x, var, n){
  
  stopifnot(is_tibble(x))
  stopifnot(is_double(n))
  
  x %>% 
    sample_n(10) %>% 
    pull({{var}}) 
}
```

<!-- DK: Note the of pull(), which I think is better because it gets rid of the names. Maybe do that above as well. Also, you would think that is_integer() would be the better test, but it is not. (Try it!) And is_numeric() is deprecated. Maybe this checking is too confusing? -->


```{r}
tibble(ID = 1:3, guess_1 = 800, guess_2 = 900) %>% 
  mutate(result = map(ID, ~ grab_a_sample(kenya, rv13, 10)))
```

We can now manipulate the `result` column and then see which prediction did better.

```{r}
tibble(ID = 1:3, guess_1 = 800, guess_2 = 900) %>% 
  mutate(result = map(ID, ~ grab_a_sample(kenya, rv13, 10))) %>% 
  mutate(biggest = map_dbl(result, ~ max(.))) %>% 
  mutate(error_1 = abs(guess_1 - biggest)) %>% 
  mutate(error_2 = abs(guess_2 - biggest)) %>% 
  mutate(winner = case_when(error_1 < error_2 ~ "Guess one wins!",
                            error_1 > error_2 ~ "Guess two wins!",
                            TRUE ~ "A tie!"))
```

Run the test 1,000 times.

```{r}
tibble(ID = 1:1000, guess_1 = 800, guess_2 = 900) %>% 
  mutate(result = map(ID, ~ grab_a_sample(kenya, rv13, 10))) %>% 
  mutate(biggest = map_dbl(result, ~ max(.))) %>% 
  mutate(error_1 = abs(guess_1 - biggest)) %>% 
  mutate(error_2 = abs(guess_2 - biggest)) %>% 
  mutate(winner = case_when(error_1 < error_2 ~ "Guess one wins!",
                            error_1 > error_2 ~ "Guess two wins!",
                            TRUE ~ "A tie!")) %>% 
  ggplot(aes(winner)) +
    geom_bar()
```

Empirically, we see than 900 is a much better guess than 800.


